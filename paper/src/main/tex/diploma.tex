\documentclass[14pt]{matmex-diploma-custom}

\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsmath}

\begin{document}
\filltitle{ru}{
    chair              = {Кафедра информационно-аналитических систем},
    title              = {Тут будет тема},
    type               = {coursework},
    author             = {Трофимов Артем Владимирович, Маршалкин Никита Евгеньевич},
    supervisorPosition = {к.\,ф.-м.\,н., доцент},
    supervisor         = {Кураленок И.\,Е.},
    faculty            = {Математико-механический факультет}
}
\filltitle{en}{
    chair              = {Sub-Department of Analytical Information Systems},
    title              = {Placeholder},
    type               = {coursework},
    author             = {Artem Trofimov, Marshalkin Nikita},
    supervisorPosition = {assistant professor},
    supervisor         = {Igor Kuralenok},
    faculty            = {Mathematics And Mechanics Faculty}
}
\maketitle

\tableofcontents

\section{Модель и архитектура}

Главной сущностью системы является поток данных протекающий через граф, узлами которого являются операции, последовательные применяемые к данным, а ребра задают порядок выполнения.

Операции физически партицированны по хешу, то есть на каждом CU выполняется весь граф, а пересылка между ними происходит, если данные поменяли хеш. Благодаря этому горизонтальная масштабируемость достигается без внесения каких-либо изменений в бизнес-логику.

Источником данных является так называемый фронт, процесс работающий на клиенте: на веб-фронте, на каком-либо сенсоре. Поскольку между порождением данных и попаданием в систему нет посредников, появляется множество полезных свойств: отсутствует задержка, которую не избежать при использовании брокеров, каждый входной элемент можем пометить “своим” временем, что позволяет получить exactly-once семантику.

Состояние системы, координационная информация хранится в  Apache Zookeeper, тем самым делегируя проблемы распределенного консенсуса.

\subsection{Время}

В нашей системе мы различаем два времени: глобальное и локальное.

\textbf{Глобальное время} - время входа элемента в систему в наносекундах с начала эпохи. Важно, что данное время - монотонно в рамках одного источника данных и два разных события имеют разное время. Первое условие достигается использованием так называемых монотонных часов. Чтобы обеспечить разность времени на разных фронтах во время вносится номер фронта. Глобальное время сравнивается лексикографически.

\[GlobalTime := (frontTs, frontId)\]

Гарантии на синхронизацию времени не требуется для корректной работы, в отличии, например от Spanner [ссылка], но от этой разницы зависит нижняя граница задержки между событием и реакцией на него (входа данных в систему и полной обработки).

\textbf{Локальное время} - логическое время каждой операции. В отличии от глобального, от него требуется лишь строгая монотонность во времени, то есть достаточно счетчика, увеличивающегося при обработке событий.

Некоторые операции могут порождать несколько элементов из одного, например  выпрямляющее отображение. Чтобы различать результаты к локальному времени добавим номер ребенка. Для отображений 1 в 1 номер ребенка будет равен нулю.

\[LocalEvent := (localTime, childId)\]


Таким образом в каждый момент времени c каждым элементом протекающем по графу ассоциирована мета-информация: глобальное время и массив локальных времен операций, через который прошел элемент к данному времени.

\[Trace := [LocalEvent]\]
\[Meta := (GlobalTime, Trace)\]
\[DataItem := (payload, Meta)\]


В дальнейшем DataItem будем называть элементом. Будет подразумеваться, что у него есть некоторое глобальное время и след, может быть пустой, если он только зашел в систему.

\subsection{Операции}

Для построения логического графа используется следующий ограниченный набор операций:

\begin{itemize}
  \item отображение без состояния (map)
  \item Выпрямляющее отображение (flatMap)
  \item группировка с окном по хешу (group)
  \item репликация (broadcast)
  \item слияние (merge).
\end{itemize}

\textbf{Отображение без состояния} применяет заданную функцию к входному элементу. Выходной элемент имеет глобальное время входного. А к следу прибавляется локальное время узла. Как понятно из названия, эта операция не имеет внутреннего состояния. Обработка двух элементов не зависит ни от порядка ни от локальности.

\textbf{Выпрямляющее отображение} сопоставляет каждому входному элементу множество выходных. Каждый элемент выходного множества впоследствии рассматривается как независимый. Все выходные элементы имеют глобальное время входного, к следу добавляется одинаковое локальное время но разный номер ребенка.


\textbf{Группировка с окном по хешу} последовательности входных элементов сопоставляет сгруппированную последовательность выходных.

Например если на вход подается последовательность натуральных чисел: \(1, 2, 3...\) , хешем является четность числа и окно - 3, то на выходе будет следующий набор кортежей:

\[(1), (2), (1|3), (2|4), (1|3|5), (2|4|6), (3|5|7)...\]

Группировка - единственная операция в нашей системе обладающая состоянием - текущая история по хешу. Соответветственно результат операции зависит от порядка входных элементов, но результаты разных хешей независимы друг от друга. Гарантируется, что в рамках хеша результат будет такой же, каким был бы, если элементы на вход подаются в соответствии с глобальным временем. Про то, как это было получено будет рассказано в следующей главе.

Глобальным временем выходного элемента является глобальное время последнего элемента в кортеже. Следом - след последнего плюс локальное время группировки. Будем говорить, что этот кортеж защищается своим последним элементом.

\textbf{Слияние} - операция с конечным числом входов и одним выходом. Каждый элемент с каждого входа подается на выход. Никаких гарантий на порядок не дается. К следу элемента добавляется локальное время операции.

\textbf{Репликация} обладает одним входном и множеством выходов.  Каждый элемент с входа подается, реплицируется на каждый выход. Аналогично выпрямлению все выходные элементы имеют глобальное время входного, к следу добавляется одинаковое локальное время но разный номер ребенка.

\subsection{Поддержание семантики группировки}

Единственной операцией для которой принципиален порядок входных данных является группировка.

Для поддержания семантики каждая операция группировки будет хранить всю историю элементов, которые к ней приходили. Назовем эту историю буфером. Поскольку группировка по различным хешам независима, такой буфер будет отдельный для каждого хеша. Элементы в буфере будут храниться в порядке порождения, то есть отсортированы по глобальному времени.

Как только приходит новый элемент он выставляется в правильную позицию в буфер. Если он самый новый в буфере, пришел в правильном порядке, то собирается обычный кортеж размером с окно и подается на выход. Если же он не самый старый, то инициируется так называемое перепроигрывание. Начинают заново порождаться кортежи, которые содержат новоприбывший элемент.

Таким образом группировка рано или поздно породит корректные кортежи. Проблемой является то, что в потоке так же будут находиться и некорректные. В этой главе мы введем необходимые определения и покажем, как определяется и удаляются некорректные элементы. Для этого достаточно будет сравнивать мета-информацию элементов.

\subsubsection{Отношение зависимости}

Введем на множестве элементов отношение зависимости. Элемент \(d_1\) зависит от \(d_0\) тогда и только тогда, когда:

\begin{itemize}
  \item они имеют одинаковое GlobalTime
  \item \(trace(d_0)\) является префиксом \(trace(d_1)\)
  \item \(|trace(d_0)| == |trace(d_1)| - 1\)
\end{itemize}

\textit{Обозначение}: \(d_0 \rightarrow d_1\). \(d_0\) - родитель \(d_1\).

Транзитивное замыкание отношения непосредственной зависимости - будем называть просто зависимостью. \textit{Обозначение}: \(d_0 \rightarrow^* d_7\). \(d_0\) - предок \(d_7\)

Каждый элементе имеет корень - элемент, имеющий такое же глобальное время и пустой след.

\begin{itemize}
  \item отображение без состояния: выходной - ребенок входного
  \item Выпрямляющее отображение: каждый выходной - ребенок входного, при этом между собой они братья
  \item группировка с окном по хешу (group): выходной - ребенок входного
  \item репликация (broadcast): каждый выходной - ребенок входного, при этом между собой они братья
  \item слияние (merge): выходной - ребенок входного
\end{itemize}

\setmonofont[Mapping=tex-text]{CMU Typewriter Text}
\bibliographystyle{ugost2008ls}
\bibliography{diploma.bib}
\end{document}
